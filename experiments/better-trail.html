<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Neon Chip Animation</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #0d0d0d;
      height: 100vh;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="chipCanvas"></canvas>

  <script>
    const canvas = document.getElementById('chipCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const HUB_COUNT = 6;
    const LIGHT_COUNT = 30;
    const ROAD_COUNT = 5;

    class Hub {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = 30;
        this.roads = [];
      }

      draw(ctx) {
        ctx.fillStyle = '#00ffcc';
        ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
      }
    }

    class Road {
      constructor(start, end) {
        this.start = start;
        this.end = end;
        this.length = Math.hypot(end.x - start.x, end.y - start.y);
      }

      draw(ctx) {
        // Invisible road
      }
    }

    class Light {
      constructor(road) {
        this.road = road;
        this.progress = Math.random();
        this.speed = 0.002 + Math.random() * 0.003;
        this.width = 8;
        this.height = 4;
        this.color = this.getRandomColor();
      }

      getRandomColor() {
        const colors = ['#00ffff', '#ff00ff', '#00ff00', '#00aaff', '#ffaa00'];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      update() {
        this.progress += this.speed;
        if (this.progress > 1) this.progress = 0;
      }

      draw(ctx) {
        const x = this.road.start.x + (this.road.end.x - this.road.start.x) * this.progress;
        const y = this.road.start.y + (this.road.end.y - this.road.start.y) * this.progress;

        ctx.save();
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 15;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.roundRect(x - this.width/2, y - this.height/2, this.width, this.height, 2);
        ctx.fill();
        ctx.restore();
      }
    }

    CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
      this.beginPath();
      this.moveTo(x + radius, y);
      this.lineTo(x + width - radius, y);
      this.quadraticCurveTo(x + width, y, x + width, y + radius);
      this.lineTo(x + width, y + height - radius);
      this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      this.lineTo(x + radius, y + height);
      this.quadraticCurveTo(x, y + height, x, y + height - radius);
      this.lineTo(x, y + radius);
      this.quadraticCurveTo(x, y, x + radius, y);
      this.closePath();
    };

    let hubs = [];
    let roads = [];
    let lights = [];

    function createHubs() {
      for (let i = 0; i < HUB_COUNT; i++) {
        const x = Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
        const y = Math.random() * canvas.height * 0.8 + canvas.height * 0.1;
        hubs.push(new Hub(x, y));
      }

      // Connect hubs with roads
      for (let i = 0; i < HUB_COUNT; i++) {
        for (let j = 0; j < ROAD_COUNT; j++) {
          const other = hubs[(i + j + 1) % HUB_COUNT];
          roads.push(new Road(hubs[i], other));
        }
      }

      // Create lights on roads
      for (let i = 0; i < LIGHT_COUNT; i++) {
        const road = roads[Math.floor(Math.random() * roads.length)];
        lights.push(new Light(road));
      }
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    function animate() {
      ctx.fillStyle = 'rgba(13, 13, 13, 0.2)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw hubs
      hubs.forEach(hub => hub.draw(ctx));

      // Draw lights
      lights.forEach(light => {
        light.update();
        light.draw(ctx);
      });

      requestAnimationFrame(animate);
    }

    window.addEventListener('resize', resizeCanvas);

    createHubs();
    animate();
  </script>
</body>
</html>

